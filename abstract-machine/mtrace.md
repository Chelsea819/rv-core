# 内存访问日志分析可视化图表解读

## 图表布局
脚本会生成 **6 个子图**，按 **3 行 × 2 列** 排列：
1. **地址时间局部性直方图**（左上）
2. **地址空间局部性直方图**（中左）
3. **PC 时间局部性直方图**（右上）
4. **PC 空间局部性直方图**（中右）
5. **地址-PC 关联热力图**（左下）
6. **操作类型分布饼图**（右下）

---

## 1. 地址时间局部性直方图
- **横轴**：内存地址的访问次数（如 1 次、2 次...）
- **纵轴**：具有该访问次数的地址数量（频次）

### 解读：
- **左侧尖峰**：大量地址被访问 1~2 次（时间局部性差）
- **右侧长尾**：少量地址被频繁访问（时间局部性好）

### 优化建议：
- 高频地址可能是热点变量，可尝试缓存优化
- 低频地址可能是临时数据，可检查内存分配合理性

---

## 2. 地址空间局部性直方图
- **横轴**：相邻访问地址的差值（字节单位）
- **纵轴**：出现该差值的频次（对数坐标）

### 解读：
- **左侧尖峰（Δ < 100）**：连续地址访问（如数组遍历，空间局部性好）
- **中间平坦区域**：随机跳跃访问（如指针操作，空间局部性差）
- **右侧长尾（Δ > 1KB）**：大跨度内存操作（如全局变量访问）

### 优化建议：
- 高频小差值：优化数据布局（如结构体对齐）
- 高频大差值：检查内存碎片化问题

---

## 3. PC 时间局部性直方图
- **横轴**：同一 PC（程序计数器）的执行次数
- **纵轴**：具有该执行次数的 PC 数量（频次）

### 解读：
- **左侧尖峰**：多数代码段只执行 1~2 次（如初始化代码）
- **右侧长尾**：少量代码段被重复执行（如循环体、高频函数）

### 优化建议：
- 高频 PC 对应热点代码，可优先优化算法
- 低频 PC 可能是冗余代码，可考虑移除

---

## 4. PC 空间局部性直方图
- **横轴**：相邻 PC 的差值（指令地址跨度）
- **纵轴**：出现该差值的频次（对数坐标）

### 解读：
- **Δ ≈ 4**：顺序执行（RISC-V 等固定指令长度架构）
- **Δ > 4**：跳转指令（如分支、函数调用）
- **Δ < 0**：反向跳转（如循环）

### 优化建议：
- 高频小跨度：优化指令流水线效率
- 高频大跨度：检查分支预测失败率

---

## 5. 地址-PC 关联热力图
- **横轴**：内存地址（对数坐标）
- **纵轴**：程序计数器 PC（对数坐标）
- **颜色深浅**：访问频次（颜色越亮频次越高）

### 解读：
- **垂直亮带**：同一 PC 访问不同地址（如循环处理数组）
- **水平亮带**：不同 PC 访问同一地址（如共享变量）
- **对角线分布**：地址与 PC 线性相关（特殊内存映射）

### 优化建议：
- 高频关联对：检查数据局部性，优化缓存策略
- 分散分布：可能需要内存访问模式重构

---

## 6. 操作类型分布饼图
- **扇形比例**：不同内存操作类型的占比
- **典型操作**：
  - `flash_read`：闪存读取
  - `sdram_read/write`：内存读写
  - `paddr_read/write`：物理地址访问

### 解读：
- **读多写少**：典型的数据处理型负载
- **写操作集中**：可能涉及频繁状态更新

### 优化建议：
- 高频写操作：检查写合并可能性
- 低频操作：评估是否可延迟执行

---

## 综合优化策略
| 现象                | 可能问题            | 优化方向                  |
|---------------------|---------------------|--------------------------|
| 地址时间局部性差     | 缓存命中率低        | 增加数据复用，调整缓存大小 |
| 地址空间局部性差     | 内存访问随机        | 优化数据结构布局          |
| PC 时间局部性集中    | 热点代码瓶颈        | 算法优化或并行化          |
| 地址-PC 关联分散     | 内存访问模式复杂    | 重构内存访问逻辑          |
| 写操作占比高         | 写带宽压力大        | 合并写操作或缓冲优化      |

---

## 分析目标
通过结合这些图表，可以：
1. 定位程序中的性能瓶颈
2. 验证缓存优化策略的有效性
3. 发现异常的内存访问模式
4. 指导硬件资源分配（如缓存大小、内存通道）